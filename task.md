## Реализации miniML коммитить сюда

Придумайте на двоих уникальное название дирекории и создавайте там проект с уникальным называнием.
Запишитесь в Excel-табличку (TODO link),
чтобы я не забыл кто есть кто.

### Зачача на допуск к экзамену

Выдается на двоих и сдается частями в виде PR в этот репо. Разумеется, там должно быть адекватное покрытие тестами, использование линтера и нормальный функциональный код (на OCaml/Haskell).

Если вы не хотите ничего знать, то можно помечать PRы заклинанием "[D] ...", и CI не будет запускать линтер, а я буду проверить только тесты, без кода. На экзамене сможете рассчитывать максимум на D.


### Описание задач

На всякий случай, скажу, что фичи не нужно реализовывать  все сразу. Итеративная модель разработки подойдет лучше водопадной.

Задание можно разбить на следующие части.

* Парсер+тайпчекер. Автоматическое тестирование парсера стоит осуществлять в том числе QuickCheck-подобным способом.
* Трансляция в ANF представление
  * Если кто-то захочет сделать CPS представление --- не возражаю.
  * В процессе построения оно должно быть адекватным. Стоит его распечатывать обратно в исходный синтаксис, и проверять, что типа (не) разъехались.
* Порождение кода для LLVM разумной версии (в том году это была 16я).
  * Код затем должен компилироваться в ELF и запускаться (QEMU). Интерпретировать LLVM биткод нельзя.
  * Печатать в тестах биткод, чтобы его можно было проверить глазами на (не)адекватность.
* Порождение ассемблерного листинга для RISC-V 64.
  * Код должен затем компилироваться в ELF стандартным RISC-V тулчейном.
  * Скомпилированные программы должны  запускаться (что-то кроме QEMU --- запрещено).
* Интегрировать в язык реализацию сборки мусора. В идеале, одну и туже и для LLVM, и для RISC-V.

### Описание MiniML

* Целые числа, булевы значения и сравнения чисел и прочая арифметика
  * Идентификаторы должны быть как в OCaml, запрещено резервировать какие-то имена, чтобы их порождать по ходу дела.
* Парсер должен работать шустро, а не парсить объявления факториала 10 секунд
* К идентификатором разрешено приписывать типы явно
* Рекурсивные функции на верхнем уровне (в компиляторе называется structure_item). С учетом каррирования
  * Разрешено переопределять операторы как функции: `let (+) = ...`
  * First-class Функции, в том числе с частичным примерением и взаимной рекурсией.
    * Вызовы функций должны быть efficient: если 3-арная функция вызывается от трёх аргументов, то нельзя делать  частичные применения.
  * Вложенные let-определения
  * Не должно быть никакого ограничения сверху на количество аргументов у функций.
* Сопоставление с образцом для кортежей и списков (полноценные алгебраические типы не обязательно).
* Рантайм: печать чисел, примитивы частичного применения и сборки мусора.
* Должны обрабатываться ошибки процессе компиляции (компилятор не должен крешиться).
